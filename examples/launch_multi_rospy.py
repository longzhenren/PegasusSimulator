#!/usr/bin/env python3
"""
Multi-instance launcher (pure Python) for `rospy_isaacsim.py`.

- Reads `multi_uav_config.json` (generated by `8_camera_vehicle.py`)
- Spawns one control process per vehicle with MAVROS URL and namespace
- Sets per-instance env vars to avoid port conflicts and enable namespacing
- Coordinates startup: waits for IsaacSim log to report `INFO [commander] Ready for takeoff!`
  exactly as many times as the number of vehicles, then launches controllers.
  The previous fixed sleep has been removed.
 - Optional: `--kill-isaac` kills any existing Isaac Sim processes before launching.

Usage:
  python3 examples/launch_multi_rospy.py \
    [--config examples/multi_uav_config.json] \
    [--script examples/rospy_isaacsim.py] \
    [--python /usr/bin/python3] \
    [--isaac examples/8_camera_vehicle.py] \
    [--session-ts 1730000000] \
    [--log-root examples/logs] \
    [--output-dir sensor_data] \
    [--pre-clean] [--force] \
    [--detach] [--kill-isaac]
Example:
    python3 examples/launch_multi_rospy.py --pre-clean --force --isaac examples/8_camera_vehicle.py
Logs:
  Each instance writes to `logs/<session_ts>/<namespace>/rospy.log`.
  Data outputs go to `<output_dir>/<session_ts>/<namespace>/...`.
"""

import argparse
import json
import os
import signal
import sys
import time
import re
from pathlib import Path
from typing import Dict, Any, List, Optional
import subprocess
import socket
import subprocess as sp

try:
    import psutil  # optional, used for robust port/name scanning
except Exception:
    psutil = None


def load_config(path: Path) -> Dict[str, Any]:
    if not path.exists():
        raise FileNotFoundError(f"Config not found: {path}")
    try:
        return json.loads(path.read_text())
    except Exception as e:
        raise RuntimeError(f"Failed to read JSON config {path}: {e}")


def ensure_dir(p: Path):
    try:
        p.mkdir(parents=True, exist_ok=True)
    except Exception:
        pass


# NOTE: The launcher now requires a valid JSON config. No implicit defaults.


def build_env(base: Dict[str, str], vid: int, mavros_url: str, mavros_ns: str, ros2_ns: Optional[str], session_ts: Optional[str]) -> Dict[str, str]:
    env = dict(base)
    env["MAVROS_URL"] = mavros_url
    env["MAVROS_NS"] = mavros_ns
    env["PEGASUS_CMD_HOST"] = env.get("PEGASUS_CMD_HOST", "0.0.0.0")
    env["PEGASUS_CMD_PORT"] = str(8989 + int(vid))
    if session_ts:
        env["PEGASUS_SESSION_TS"] = str(session_ts)

    # Per-instance camera topics and per-instance output directory to avoid collisions
    # Use provided ROS2 namespace as-is; it already includes vehicle id in config
    ns_for_topics = (ros2_ns or mavros_ns)
    camera_name = f"front_camera_{vid}"
    # 摄像头完整话题：/<ns>/<camera_name>/color/image_raw 与 /<ns>/<camera_name>/depth
    # 摄像头完整话题：/<ns>/<camera_name>/color/image_raw 与 /<ns>/<camera_name>/depth
    # 注意：摄像头话题来自 IsaacSim，不在 mavros 命名空间下
    env["PEGASUS_CAMERA_RGB"] = f"/{ns_for_topics}/{camera_name}/color/image_raw"
    env["PEGASUS_CAMERA_DEPTH"] = f"/{ns_for_topics}/{camera_name}/depth"

    # Prefix output save root with namespace
    base_root = env.get("PEGASUS_OUTPUT_DIR", env.get("PEGASUS_SAVE_DIR", "sensor_data"))
    parts = [base_root]
    if session_ts:
        parts.append(str(session_ts))
    parts.append(mavros_ns)
    env["PEGASUS_OUTPUT_DIR"] = os.path.join(*parts)
    return env


def start_instance(python_exe: str, script_path: Path, mavros_url: str, mavros_ns: Optional[str], env: Dict[str, str], log_path: Path) -> subprocess.Popen:
    cmd: List[str] = [python_exe, str(script_path), "--mavros-url", mavros_url]
    if mavros_ns:
        cmd += ["--mavros-ns", mavros_ns]
        # 传递 ROS2 全局命名空间参数，使用全限定形式
        # Python 节点自身可保持不在命名空间；这里仅用于统一日志路径
        # 若仍需设置，将其设为 '/<ns>'（不含 '/mavros'），避免节点名称带入 'mavros'
        cmd += ["--ros-args", "--namespace", f"/{mavros_ns}"]
    # Also pass output dir explicitly to the child (env still set for safety)
    out_dir = env.get("PEGASUS_OUTPUT_DIR")
    if out_dir:
        cmd += ["--output-dir", out_dir]
    
    # Print the command that will be executed
    print(f"[INFO] Executing command: {' '.join(cmd)}")

    log_f = log_path.open("w")
    proc = subprocess.Popen(cmd, stdout=log_f, stderr=subprocess.STDOUT, env=env)
    # attach file handle for cleanup
    setattr(proc, "_log_file", log_f)
    return proc


def terminate_all(procs: List[subprocess.Popen], timeout: float = 5.0):
    # Graceful terminate, then kill if needed
    for p in procs:
        if p.poll() is None:
            try:
                p.terminate()
            except Exception:
                pass
    t0 = time.time()
    while time.time() - t0 < timeout:
        if all(p.poll() is not None for p in procs):
            break
        time.sleep(0.2)
    for p in procs:
        if p.poll() is None:
            try:
                p.kill()
            except Exception:
                pass
        # close log files
        lf = getattr(p, "_log_file", None)
        try:
            if lf:
                lf.close()
        except Exception:
            pass


def main():
    parser = argparse.ArgumentParser(description="Launch multiple rospy_isaacsim.py controllers from JSON config")
    default_dir = Path(__file__).resolve().parent
    parser.add_argument("--config", type=str, default=str(default_dir / "multi_uav_config.json"), help="Path to multi-UAV JSON config")
    parser.add_argument("--script", type=str, default=str(default_dir / "rospy_isaacsim.py"), help="Path to control script")
    parser.add_argument("--python", type=str, default=sys.executable, help="Python executable for child processes")
    parser.add_argument("--isaac", type=str, default=str(default_dir / "8_camera_vehicle.py"), help="IsaacSim scene script to run before controllers")
    parser.add_argument("--session-ts", type=str, default=None, help="Override session timestamp (string or int)")
    parser.add_argument("--log-root", type=str, default=str(default_dir / "logs"), help="Root directory for logs")
    parser.add_argument("--output-dir", type=str, default=None, help="Root directory for outputs (defaults to sensor_data)")
    parser.add_argument("--pre-clean", action="store_true", help="Scan and kill residual processes occupying ports or named mavros/px4")
    parser.add_argument("--force", action="store_true", help="Skip Y/N confirmation when pre-clean is requested")
    parser.add_argument("--detach", action="store_true", help="Do not wait; exit after starting children")
    parser.add_argument("--kill-isaac", action="store_true", help="启动前杀掉已有 Isaac Sim 进程")
    args = parser.parse_args()

    config_path = Path(args.config)
    script_path = Path(args.script)
    python_exe = args.python

    if not script_path.exists():
        print(f"[ERROR] Control script not found: {script_path}")
        sys.exit(1)

    # Load mandatory JSON config; do not auto-initialize defaults
    try:
        cfg = load_config(config_path)
    except Exception as e:
        print(f"[ERROR] {e}")
        sys.exit(1)

    vehicles = cfg.get("vehicles", [])
    if not vehicles:
        print(f"[ERROR] No vehicles found in config {config_path}")
        sys.exit(1)

    # Unify session timestamp across instances: cli > env > now
    session_ts = args.session_ts or os.environ.get("PEGASUS_SESSION_TS") or str(int(time.time()))
    base_env = os.environ.copy()
    base_env["PEGASUS_SESSION_TS"] = session_ts
    if args.output_dir:
        base_env["PEGASUS_OUTPUT_DIR"] = args.output_dir

    # Prepare log root
    log_root = Path(args.log_root)
    ensure_dir(log_root)

    # --- Pre-clean phase: kill by port and by name ---
    cleaned_pids: List[int] = []

    def _confirm(prompt: str) -> bool:
        if args.force:
            return True
        try:
            ans = input(f"{prompt} [y/N]: ").strip().lower()
            return ans in ("y", "yes")
        except Exception:
            return False

    def _find_pids_by_port(port: int) -> List[int]:
        pids: List[int] = []
        # Try psutil first
        if psutil is not None:
            try:
                for conn in psutil.net_connections(kind='tcp'):
                    if conn.laddr and conn.laddr.port == port and conn.pid:
                        pids.append(conn.pid)
                for conn in psutil.net_connections(kind='udp'):
                    if conn.laddr and conn.laddr.port == port and conn.pid:
                        pids.append(conn.pid)
            except Exception:
                pass
        # Fallback to lsof
        if not pids:
            try:
                out = sp.check_output(["lsof", "-i", f":{port}", "-t"], stderr=sp.DEVNULL).decode().strip()
                for line in out.splitlines():
                    try:
                        pids.append(int(line))
                    except Exception:
                        pass
            except Exception:
                # Fallback to ss
                try:
                    out = sp.check_output(["ss", "-lnptu"], stderr=sp.DEVNULL).decode().splitlines()
                    for line in out:
                        if f":{port} " in line or line.strip().endswith(f":{port}"):
                            # Extract pid via users:(("name",pid=123,fd=...))
                            if "pid=" in line:
                                try:
                                    seg = line.split("pid=")[1]
                                    pid = int(seg.split(",")[0])
                                    pids.append(pid)
                                except Exception:
                                    pass
                except Exception:
                    pass
        return list(sorted(set(pids)))

    def _kill_pid(pid: int):
        try:
            if psutil is not None:
                p = psutil.Process(pid)
                p.terminate()
                try:
                    p.wait(timeout=3)
                except Exception:
                    p.kill()
            else:
                os.kill(pid, signal.SIGTERM)
                time.sleep(0.2)
                try:
                    os.kill(pid, signal.SIGKILL)
                except Exception:
                    pass
            cleaned_pids.append(pid)
        except Exception:
            pass

    def _find_pids_by_name(substrs: List[str]) -> List[int]:
        hits: List[int] = []
        if psutil is not None:
            try:
                for p in psutil.process_iter(['pid', 'name', 'cmdline']):
                    name = (p.info.get('name') or '').lower()
                    cmd = ' '.join(p.info.get('cmdline') or []).lower()
                    if any(s in name or s in cmd for s in substrs):
                        hits.append(p.info['pid'])
            except Exception:
                pass
        else:
            try:
                out = sp.check_output(["ps", "-eo", "pid,comm,args"], stderr=sp.DEVNULL).decode().splitlines()
                for line in out:
                    low = line.lower()
                    if any(s in low for s in substrs):
                        try:
                            pid = int(low.split()[0])
                            hits.append(pid)
                        except Exception:
                            pass
            except Exception:
                pass
        return list(sorted(set(hits)))

    if args.pre_clean:
        # Aggregate candidate ports (command ports and PX4 MAVLink base ports)
        candidate_ports = set()
        for v in vehicles:
            vid = int(v.get("vehicle_id", 0))
            candidate_ports.add(8989 + vid)  # PEGASUS_CMD_PORT
            candidate_ports.add(14540 + vid) # PX4/MAVLink base port
        name_patterns = ["mavros", "px4", "px4-sitl", "mavros_node", "ros2 launch mavros"]
        print(f"[CLEAN] Candidate ports: {sorted(candidate_ports)}; names: {name_patterns}")
        if _confirm("Proceed to kill processes occupying listed ports and matching names?"):
            # kill by port
            for port in sorted(candidate_ports):
                pids = _find_pids_by_port(port)
                for pid in pids:
                    # don't kill self
                    if pid != os.getpid():
                        _kill_pid(pid)
            # kill by name
            for pid in _find_pids_by_name(name_patterns):
                if pid != os.getpid():
                    _kill_pid(pid)
            print(f"[CLEAN] Killed PIDs: {sorted(set(cleaned_pids))}")
        else:
            print("[CLEAN] Skipped by user.")

    # --- Optional: kill existing Isaac Sim processes before launching scene ---
    if args.kill_isaac:
        try:
            isaac_path_hint = os.environ.get("ISAACSIM_PATH", "")
            isaac_patterns = [
                "isaacsim",
                "Isaac-Sim",
                "omni.isaac",
                "Kit/Isaac-Sim",
            ]
            if isaac_path_hint:
                isaac_patterns.append(isaac_path_hint.lower())
            print(f"[CLEAN] Killing Isaac Sim processes by patterns: {isaac_patterns}")
            for pid in _find_pids_by_name([p.lower() for p in isaac_patterns]):
                if pid != os.getpid():
                    _kill_pid(pid)
            killed = sorted(set(cleaned_pids))
            if killed:
                print(f"[CLEAN] IsaacSim PIDs killed: {killed}")
            else:
                print("[CLEAN] No IsaacSim processes found to kill.")
        except Exception as e:
            print(f"[WARN] Failed to kill IsaacSim processes: {e}")

    procs: List[subprocess.Popen] = []

    def _signal_handler(sig, frame):
        print(f"\n[SIGNAL] Received {sig}. Cleaning up child processes...")
        terminate_all(procs)
        # also stop isaac sim if running
        try:
            if 'isaac_proc' in globals() or 'isaac_proc' in locals():
                pass
        except Exception:
            pass
        sys.exit(0)

    # Register signal handlers for graceful shutdown
    signal.signal(signal.SIGINT, _signal_handler)
    signal.signal(signal.SIGTERM, _signal_handler)

    # --- Integrate Isaac Sim scene startup (optional, launched first) ---
    isaac_proc = None
    if args.isaac:
        try:
            isaac_py = os.environ.get("ISAACSIM_PYTHON")
            if not isaac_py:
                # fallback to ISAACSIM_PATH/python.sh, else to repo tools/packman/python.sh
                candidate = os.path.join(os.environ.get("ISAACSIM_PATH", ""), "python.sh")
                if os.path.isfile(candidate):
                    isaac_py = candidate
                else:
                    repo_py = Path(__file__).resolve().parents[1] / "tools" / "packman" / "python.sh"
                    isaac_py = str(repo_py)
            isaac_cmd = [isaac_py, str(Path(args.isaac))]
            isaac_log_dir = log_root / str(session_ts) / "isaac"
            ensure_dir(isaac_log_dir)
            isaac_log = isaac_log_dir / "isaacsim.log"
            isaac_log_f = isaac_log.open("w")
            now_str = time.strftime("%Y-%m-%d %H:%M:%S")
            print(f"[提示] 场景加载中... 当前时间: {now_str}")
            isaac_proc = subprocess.Popen(isaac_cmd, stdout=isaac_log_f, stderr=subprocess.STDOUT, env=base_env)
            setattr(isaac_proc, "_log_file", isaac_log_f)
            print(f"[LAUNCH] ISAACSIM scene: {args.isaac} pid={isaac_proc.pid} logs: {isaac_log}")

            # Wait for simulator readiness by watching log markers, then gate on PX4 commander messages
            def _wait_for_isaac_ready(log_path: Path, timeout: float = 3600.0) -> bool:
                start = time.time()
                last_size = 0
                ready_markers = [
                    "Simulator connected on TCP port",
                    "World reset",
                    "PegasusApp Simulation App is closing."  # unlikely, but end marker
                ]
                while time.time() - start < timeout:
                    try:
                        if log_path.exists():
                            data = log_path.read_text()
                            if len(data) != last_size:
                                last_size = len(data)
                                # check markers
                                low = data.lower()
                                if any(m.lower() in low for m in ready_markers):
                                    return True
                    except Exception:
                        pass
                    time.sleep(1.0)
                return False

            if not _wait_for_isaac_ready(isaac_log):
                print("[WARN] Isaac Sim readiness not confirmed within timeout; continuing to launch controllers.")
        except Exception as e:
            print(f"[WARN] Failed to start ISAACSIM scene: {e}")
    
    # --- Readiness gate: wait until all vehicles report 'Ready for takeoff!' in IsaacSim log ---
    def _wait_for_all_ready(log_path: Path, expected_count: int, timeout: float = 900.0) -> bool:
        """Tail IsaacSim log until commander reports 'Ready for takeoff!' expected_count times.
        Matches robustly even with ANSI color codes and variable spacing.
        """
        start = time.time()
        last_size = 0
        pattern = re.compile(r"INFO\s*\[commander\].*?Ready for takeoff!", re.MULTILINE)
        seen = 0
        while time.time() - start < timeout:
            try:
                if log_path.exists():
                    data = log_path.read_text(errors="ignore")
                    if len(data) != last_size:
                        last_size = len(data)
                        seen = len(pattern.findall(data))
                        print(f"[READY] Commander ready count: {seen}/{expected_count}")
                        if seen >= expected_count:
                            return True
            except Exception:
                pass
            time.sleep(1.0)
        return False

    expected_aircraft = len(vehicles)
    if expected_aircraft > 0 and args.isaac:
        isaac_log_path = log_root / str(session_ts) / "isaac" / "isaacsim.log"
        print(f"[提示] 等待所有飞机就绪（Ready for takeoff!）：{expected_aircraft} 架 | 当前时间: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        ok = _wait_for_all_ready(isaac_log_path, expected_aircraft, timeout=1800.0)
        if not ok:
            print(f"[WARN] Did not observe '{expected_aircraft}' Ready for takeoff! messages within timeout; proceeding anyway.")

    # Launch per vehicle (controllers)
    for v in vehicles:
        vid = int(v.get("vehicle_id", 0))
        mavros_url = v.get("mavros_fcu_url", f"udp://:{14540 + vid}@")
        mavros_ns = v.get("mavros_namespace", f"uav{vid}")
        ros2_ns = v.get("ros2_namespace", f"uav{vid}")

        env = build_env(base_env, vid, mavros_url, mavros_ns, ros2_ns, session_ts)

        # logs/<session_ts>/<ns>/rospy.log
        log_dir = log_root / str(session_ts) / str(mavros_ns)
        ensure_dir(log_dir)
        log_path = log_dir / "rospy.log"
        try:
            print(f"[PARAMS] vehicle_id={vid} mavros_url={mavros_url} mavros_ns={mavros_ns} ros2_ns={ros2_ns} cmd_port={env['PEGASUS_CMD_PORT']}")
            print(f"         output_dir={env.get('PEGASUS_OUTPUT_DIR')}")
            proc = start_instance(python_exe, script_path, mavros_url, mavros_ns, env, log_path)
            procs.append(proc)
            print(f"[LAUNCH] vehicle_id= {vid} pid= {proc.pid} logs= {log_path}")
        except Exception as e:
            print(f"[ERROR] Failed to launch vehicle_id={vid}: {e}")

    # Isaac proc already handled above

    if args.detach:
        print(f"[INFO] Detached mode. Spawned {len(procs)} processes.")
        return

    print("[INFO] Waiting for child processes. Press Ctrl+C to stop.")
    print(f"[INFO] Session TS: {session_ts} | Log root: {log_root}")
    # Wait for children and report exits
    try:
        while True:
            alive = 0
            for p in list(procs):
                rc = p.poll()
                if rc is None:
                    alive += 1
                else:
                    print(f"[EXIT] PID {p.pid} finished with code {rc}")
                    lf = getattr(p, "_log_file", None)
                    try:
                        if lf:
                            lf.close()
                    except Exception:
                        pass
                    procs.remove(p)
            # also monitor isaac_proc
            if isaac_proc is not None:
                rc = isaac_proc.poll()
                if rc is not None:
                    print(f"[EXIT] ISAACSIM PID {isaac_proc.pid} finished with code {rc}")
                    lf = getattr(isaac_proc, "_log_file", None)
                    try:
                        if lf:
                            lf.close()
                    except Exception:
                        pass
                    isaac_proc = None
            if alive == 0 and (isaac_proc is None):
                break
            time.sleep(0.5)
    except KeyboardInterrupt:
        _signal_handler("KeyboardInterrupt", None)

    print("[INFO] All controllers finished.")
    if cleaned_pids:
        print(f"[INFO] Cleaned PIDs at start: {sorted(set(cleaned_pids))}")


if __name__ == "__main__":
    main()